<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Heart Beat Smooth Fix</title>
  <style>
    html, body { margin:0; padding:0; overflow:hidden; background:#000; }
    canvas { display:block; }
  </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TrackballControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
<script>
// Simple fake noise
class SimplexNoise {
  noise4D(x,y,z,w) {
    return Math.sin(x*10 + y*10 + z*10 + w);
  }
}

class MeshSurfaceSampler {
  constructor(mesh) {
    this.geometry = mesh.geometry;
    this.position = this.geometry.attributes.position;
    this.faceCount = this.position.count / 3;
  }
  build(){ return this; }
  sample(target){
    let face = Math.floor(Math.random() * this.faceCount);
    let a = face*3, b=a+1, c=a+2;
    let u = Math.random(), v = Math.random();
    if(u+v>1){u=1-u; v=1-v;}
    let pa = new THREE.Vector3().fromBufferAttribute(this.position,a);
    let pb = new THREE.Vector3().fromBufferAttribute(this.position,b);
    let pc = new THREE.Vector3().fromBufferAttribute(this.position,c);
    target.copy(pa).multiplyScalar(u)
      .add(pb.clone().multiplyScalar(v))
      .add(pc.clone().multiplyScalar(1-u-v));
  }
}

let scene = new THREE.Scene();
let camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
let renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setClearColor(0x000000);
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);
camera.position.z = 1.8;

let controls = new THREE.TrackballControls(camera, renderer.domElement);
controls.noPan = true;
controls.maxDistance = 3;
controls.minDistance = 0.7;

let group = new THREE.Group();
scene.add(group);

let heart, sampler, spikes=[], positions=[], colors=[];
let geometry = new THREE.BufferGeometry();
let material = new THREE.PointsMaterial({vertexColors:true, size:0.009});
let particles = new THREE.Points(geometry, material);
group.add(particles);

const simplex = new SimplexNoise();
const palette = [
  new THREE.Color("#ffd4ee"),
  new THREE.Color("#ff77fc"),
  new THREE.Color("#ff77ae"),
  new THREE.Color("#ff1775"),
];

class SparkPoint {
  constructor(){
    let pos = new THREE.Vector3();
    sampler.sample(pos);
    this.color = palette[Math.floor(Math.random()*palette.length)];
    this.rand = Math.random()*0.03;
    this.pos = pos.clone();
    this.one=null; this.two=null;
  }
  update(a){
    const noise = simplex.noise4D(this.pos.x,this.pos.y,this.pos.z,a*0.2)+1.5;
    const noise2= simplex.noise4D(this.pos.x*500,this.pos.y*500,this.pos.z*500,a*0.3)+1;
    this.one = this.pos.clone().multiplyScalar(1.01 + noise*0.05);
    this.two = this.pos.clone().multiplyScalar(1 + noise2*0.1);
  }
}

function initSpikes(){
  spikes=[];
  for(let i=0;i<8000;i++) spikes.push(new SparkPoint());
}

const maxZ=0.23, rateZ=0.5;
let clock=new THREE.Clock();

function render(){
  if(!heart) return;
  let t=clock.getElapsedTime();

  // ❤️ Heartbeat scale (uniform)
  let s=1+Math.sin(t*4)*0.1; // speed=4, size change=0.1
  group.scale.set(s,s,s);

  positions=[]; colors=[];
  spikes.forEach(g=>{
    g.update(t);
    const rand=g.rand, color=g.color;
    if(maxZ*rateZ+rand>g.one.z && g.one.z>-maxZ*rateZ-rand){
      positions.push(g.one.x,g.one.y,g.one.z);
      colors.push(color.r,color.g,color.b);
    }
    if(maxZ*rateZ+rand*2>g.one.z && g.one.z>-maxZ*rateZ-rand*2){
      positions.push(g.two.x,g.two.y,g.two.z);
      colors.push(color.r,color.g,color.b);
    }
  });

  geometry.setAttribute("position",new THREE.BufferAttribute(new Float32Array(positions),3));
  geometry.setAttribute("color",new THREE.BufferAttribute(new Float32Array(colors),3));

  controls.update();
  renderer.render(scene,camera);
  requestAnimationFrame(render);
}

window.addEventListener("resize",()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

new THREE.OBJLoader().load(
  "https://assets.codepen.io/127738/heart_2.obj",
  obj=>{
    heart=obj.children[0];
    heart.geometry.rotateX(-Math.PI*0.5);
    heart.geometry.scale(0.04,0.04,0.04);
    heart.geometry.translate(0,-0.4,0);
    heart.visible=false;
    sampler=new MeshSurfaceSampler(heart).build();
    initSpikes();
    render();
  }
);
</script>
</body>
</html>
